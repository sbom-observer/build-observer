// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || arm || arm64 || loong64 || mips64le || mipsle || ppc64le || riscv64

package traceopens

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

// loadTraceopens returns the embedded CollectionSpec for traceopens.
func loadTraceopens() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_TraceopensBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load traceopens: %w", err)
	}

	return spec, err
}

// loadTraceopensObjects loads traceopens and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*traceopensObjects
//	*traceopensPrograms
//	*traceopensMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadTraceopensObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadTraceopens()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// traceopensSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type traceopensSpecs struct {
	traceopensProgramSpecs
	traceopensMapSpecs
	traceopensVariableSpecs
}

// traceopensProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type traceopensProgramSpecs struct {
	HandleExecveEnter *ebpf.ProgramSpec `ebpf:"handle_execve_enter"`
	HandleExecveExit  *ebpf.ProgramSpec `ebpf:"handle_execve_exit"`
	HandleFork        *ebpf.ProgramSpec `ebpf:"handle_fork"`
	HandleOpenatEnter *ebpf.ProgramSpec `ebpf:"handle_openat_enter"`
	HandleOpenatExit  *ebpf.ProgramSpec `ebpf:"handle_openat_exit"`
}

// traceopensMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type traceopensMapSpecs struct {
	Events  *ebpf.MapSpec `ebpf:"events"`
	ExecMap *ebpf.MapSpec `ebpf:"exec_map"`
	PathMap *ebpf.MapSpec `ebpf:"path_map"`
	Pids    *ebpf.MapSpec `ebpf:"pids"`
}

// traceopensVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type traceopensVariableSpecs struct {
}

// traceopensObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadTraceopensObjects or ebpf.CollectionSpec.LoadAndAssign.
type traceopensObjects struct {
	traceopensPrograms
	traceopensMaps
	traceopensVariables
}

func (o *traceopensObjects) Close() error {
	return _TraceopensClose(
		&o.traceopensPrograms,
		&o.traceopensMaps,
	)
}

// traceopensMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadTraceopensObjects or ebpf.CollectionSpec.LoadAndAssign.
type traceopensMaps struct {
	Events  *ebpf.Map `ebpf:"events"`
	ExecMap *ebpf.Map `ebpf:"exec_map"`
	PathMap *ebpf.Map `ebpf:"path_map"`
	Pids    *ebpf.Map `ebpf:"pids"`
}

func (m *traceopensMaps) Close() error {
	return _TraceopensClose(
		m.Events,
		m.ExecMap,
		m.PathMap,
		m.Pids,
	)
}

// traceopensVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadTraceopensObjects or ebpf.CollectionSpec.LoadAndAssign.
type traceopensVariables struct {
}

// traceopensPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadTraceopensObjects or ebpf.CollectionSpec.LoadAndAssign.
type traceopensPrograms struct {
	HandleExecveEnter *ebpf.Program `ebpf:"handle_execve_enter"`
	HandleExecveExit  *ebpf.Program `ebpf:"handle_execve_exit"`
	HandleFork        *ebpf.Program `ebpf:"handle_fork"`
	HandleOpenatEnter *ebpf.Program `ebpf:"handle_openat_enter"`
	HandleOpenatExit  *ebpf.Program `ebpf:"handle_openat_exit"`
}

func (p *traceopensPrograms) Close() error {
	return _TraceopensClose(
		p.HandleExecveEnter,
		p.HandleExecveExit,
		p.HandleFork,
		p.HandleOpenatEnter,
		p.HandleOpenatExit,
	)
}

func _TraceopensClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed traceopens_bpfel.o
var _TraceopensBytes []byte
